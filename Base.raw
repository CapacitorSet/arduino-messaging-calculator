#define DEBUG true
#define SHIFT_KEY_PIN 4
#define CTRL_KEY_PIN 3
#define LCD_COLS 16
#define LCD_ROWS 2
#define LCD_0 A0
#define LCD_1 A1
#define LCD_2 A2
#define LCD_3 A3
#define LCD_4 A4
#define LCD_5 A5

#define RESULT_PRECISION 8
#define RESULT_MAX_SIZE 64

#define MAX_MSG_SIZE 64
#define DISPLAY_SIZE 16

#include <StackList.h>
#include "infix_postfix.h"
#include "evaluate_postfix.h"
#include "conversion_tools.h"
#include <LiquidCrystal.h>
#include <Keypad.h>

#define ROWS 4
#define COLS 4
char keys[ROWS][COLS] = {
	{'1','2','3','+'},
	{'4','5','6','-'},
	{'7','8','9','*'},
	{'S','0','D','/'}
};
byte rowPins[ROWS] = {12, 11, 10, 9};
byte colPins[COLS] = { 8,  7,  6, 5};


// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(LCD_0, LCD_1, LCD_2, LCD_3, LCD_4, LCD_5);
Keypad customKeypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
bool clearScreen = true; // Per cancellare lo splash screen

// Per la comunicazione
char messaggio[MAX_MSG_SIZE+1];
char inChar=-1; // Where to store the character read
int index = 0; // Index into array; where to store the character
bool newMessage = false;
bool readMsg = false;
bool inviato = false;

// Per il multitap
char prevKey = '\0';
int tapCount = 0;
bool textMode = false;
unsigned long time = 0;

// Per scrivere
String buffer;
String expression;
int latestExpressionLength; // So that backspace works correctly with eg. log or tan


void setup () {
	#if DEBUG
		Serial.begin (9600);
	#endif
	Serial1.begin(9600);

	// Set up the LCD
	lcd.begin(LCD_COLS, LCD_ROWS);
	lcd.print("Tette *-*");

	pinMode(SHIFT_KEY_PIN, INPUT_PULLUP);
	pinMode(CTRL_KEY_PIN, INPUT_PULLUP);
}

void printExpr(String expression) {
	lcd.print(expression);
    if(expression.length() > DISPLAY_SIZE - 1) {
		#if DEBUG
			Serial.println("Auto Scrolling");
		#endif
		for (int i = 0; i <= expression.length() - DISPLAY_SIZE; i++) {
			lcd.scrollDisplayLeft();
		}
	}
}

void clear_array(char *string, int length){
	for (int i = 0; i < length; i++)
		string[i] = '\0';
}

void send() {
	if (textMode){
		Serial1.print(expression);
		inviato = true;
	}
	if (DEBUG)
		Serial.println(expression);
}

void loop () {

	const char key = customKeypad.getKey();
	bool printBuffer = true;
	bool clearScreen = true;

	if (key) {
		const bool shift = !digitalRead(SHIFT_KEY_PIN);
		const bool ctrl  = !digitalRead(CTRL_KEY_PIN);

		if (textMode == true) {
			if (key == prevKey && (millis() - time) < 1000) {
					tapCount++;
					expression = expression.substring(0, expression.length() - 1);
					time = millis();
			} // Cancella il token precedente
			else {
				tapCount=0;
				prevKey = '\0';
				time = millis();
			}
		}

		switch (key) {
			case '5':
				if (shift && ctrl) {
					printBuffer = false;
					clearScreen = false;
					textMode = !textMode;
					expression = "";
					buffer = "";
					#if DEBUG
						Serial.print("Toggling textMode");
					#endif
				}
				break;
			case 'S':
				if (shift && ctrl) {
					lcd.scrollDisplayLeft();
				} else if(textMode) {
					if (ctrl) 
						readMsg = true;
					else{
						printBuffer = false,
						clearScreen = false;
						send();
					}
				} else {
					printBuffer = false;
					clearScreen = false;
					lcd.setCursor(0, 1);

					String postfix;
					double result, Ans;
					String prevAns;
					char value[RESULT_MAX_SIZE]; // as string
					
					if (infix_postfix (buffer, postfix)) { // try to convert the infix expression to postfix.
						#if SERIAL_DEBUG
							Serial.print("Postfix: ");
							Serial.println(postfix);
						#endif

						// try to evaluate the postfix expression.
						if (evaluate_postfix (postfix, result)) {
							Ans = result;
							// convert the result as string.
							double_string (value, result, RESULT_PRECISION);

							// print the result
							lcd.print(value);
							prevAns = value;
						} else {
							lcd.write("Can'tEvalPostfix");
							#if DEBUG
								Serial.println(postfix);
							#endif
						}
					} else {
						lcd.write("CantConvert2Infx");
						#if DEBUG
							Serial.println(buffer);
						#endif
					}
					buffer     = "";
					expression = "";
				} // It's magic *-* - CapacitorSet
				// Don't question it. Anche perchè neanch'io ho idea di come funzioni. - CapacitorSet
				break;
			case 'D':
				if (shift && ctrl) {
					lcd.scrollDisplayRight();
				} else {
					buffer = buffer.substring(0, buffer.length() - 1);
					expression = expression.substring(0, expression.length() - latestExpressionLength);
					prevKey = '\0'; // E' difficile da spiegare, ma va tenuto altrimenti non si comporta in modo naturale per l'utente.
					// ^ Ora non ho neanche idea di come funzioni, quindi: TODO: capire perché c'è la riga sopra. - CapacitorSet
				}
				break;
		}

		switch (key) {
			/* KEYS */
			// Don't delete the comment above, it is required by make.js.
			// If you wish to implement custom behaviour for a key, do so in the switch statement above this one.
		}

		if (clearScreen == true) {
			lcd.clear();
		}

		if (printBuffer == true) {
			#if DEBUG
				Serial.print("Printing ");
				Serial.println(expression);
			#endif
			lcd.setCursor(0, 0);
			printExpr(expression);
		}
		prevKey = key;
	}

	if (Serial1.available()) {
		if (readMsg) {
			clear_array(messaggio, MAX_MSG_SIZE);
			index = 0;
			readMsg = false;
		}
		delay(20);
		if (index > 0){
			if(DEBUG)
				Serial.println("Nuovo messaggio aggiunto in coda");
			messaggio[index++] = '-';
		}
		while (Serial1.available()){
			inChar = Serial1.read(); // Read a character
			#if DEBUG
				Serial.println(inChar);
			#endif
			if(index < MAX_MSG_SIZE - 1) {
				messaggio[index] = inChar; // Store it
				index++;
			}
		}
		messaggio[index] = '\0';
		newMessage = true;
	}

	if (newMessage && textMode) {
		lcd.clear();
		lcd.setCursor(0, 0);
		lcd.print(expression);
		if (inviato) {
			lcd.print(" INVIATO!");
			expression = "";
			inviato = false;
		}
		newMessage = false;
	}

	if (textMode) {
		lcd.setCursor(0, 1);
		lcd.print(messaggio);
	}
}


