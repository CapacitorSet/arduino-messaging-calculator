#define DEBUG true
#define SHIFT_KEY_PIN 4
#define CTRL_KEY_PIN 3
#define LCD_COLS 16
#define LCD_ROWS 2
#define LCD_0 A0
#define LCD_1 A1
#define LCD_2 A2
#define LCD_3 A3
#define LCD_4 A4
#define LCD_5 A5

#define RESULT_PRECISION 8
#define RESULT_MAX_SIZE 64

#define MAX_MSG_SIZE 64
#define DISPLAY_SIZE 16

#include <StackList.h>
#include "infix_postfix.h"
#include "evaluate_postfix.h"
#include "conversion_tools.h"
#include <LiquidCrystal.h>
#include <Keypad.h>

#define ROWS 4
#define COLS 4
char keys[ROWS][COLS] = {
	{'1','2','3','+'},
	{'4','5','6','-'},
	{'7','8','9','*'},
	{'S','0','D','/'}
};
byte rowPins[ROWS] = {12, 11, 10, 9};
byte colPins[COLS] = { 8,  7,  6, 5};


// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(LCD_0, LCD_1, LCD_2, LCD_3, LCD_4, LCD_5);
Keypad customKeypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
bool clearScreen = true; // Per cancellare lo splash screen

// Per la comunicazione
char messaggio[MAX_MSG_SIZE+1];
char inChar=-1; // Where to store the character read
byte index = 0; // Index into array; where to store the character
bool newMessage = true;

// Per il multitap
char prevKey = '\0';
int tapCount = 0;
bool textMode = false;
unsigned long time = 0;

// Per scrivere
String buffer;
String expression;
int latestExpressionLength; // So that backspace works correctly with eg. log or tan


void setup () {
	#if DEBUG
		Serial.begin (9600);
	#endif
	Serial1.begin(9600);

	// Set up the LCD
	lcd.begin(LCD_COLS, LCD_ROWS);
	lcd.print("Tette *-*");

	pinMode(SHIFT_KEY_PIN, INPUT_PULLUP);
	pinMode(CTRL_KEY_PIN, INPUT_PULLUP);
}

void printExpr(String expression) {
	lcd.print(expression);
    if(expression.length() > DISPLAY_SIZE - 1) {
		#if DEBUG
			Serial.println("Auto Scrolling");
		#endif
		for (int i = 0; i <= expression.length() - DISPLAY_SIZE; i++) {
			lcd.scrollDisplayLeft();
		}
	}
}

void loop () {
	if (Serial1.available()) {
		newMessage = true;
		inChar = Serial1.read(); // Read a character
		#if DEBUG
			Serial.println(inChar);
		#endif
		if (inChar == '£') {
			for (int i = 0; i < MAX_MSG_SIZE+1; i++) {
				messaggio[i] = '\0';
			}
		}
		if(index < MAX_MSG_SIZE) {
			messaggio[index] = inChar; // Store it
			messaggio[++index] = '\0'; // Null terminate the string
		}
	}

	const char key = customKeypad.getKey();
	bool printBuffer = true;
	bool clearScreen = true;

	if (key) {
		const bool shift = !digitalRead(SHIFT_KEY_PIN);
		const bool ctrl  = !digitalRead(CTRL_KEY_PIN);

		if (textMode == true) {
			if (key == prevKey && (millis() - time) < 1000) {
					tapCount++;
					expression = expression.substring(0, expression.length() - 1);
					time = millis();
			} // Cancella il token precedente
			else {
				tapCount=0;
				prevKey = '\0';
				time = millis();
			}
		}

		switch (key) {
			case '5':
				if (shift && ctrl) {
					printBuffer = false;
					clearScreen = false;
					textMode = !textMode;
					#if DEBUG
						Serial.print("Toggling textMode");
					#endif
				}
				break;
			case 'S':
				if (shift && ctrl) {
					lcd.scrollDisplayLeft();
				} else {
					printBuffer = false;
					clearScreen = false;
					lcd.setCursor(0, 1);

					String postfix;
					double result, Ans;
					String prevAns;
					char value[RESULT_MAX_SIZE]; // as string
					
					if (infix_postfix (buffer, postfix)) { // try to convert the infix expression to postfix.
						#if SERIAL_DEBUG
							Serial.print("Postfix: ");
							Serial.println(postfix);
						#endif

						// try to evaluate the postfix expression.
						if (evaluate_postfix (postfix, result)) {
							Ans = result;
							// convert the result as string.
							double_string (value, result, RESULT_PRECISION);

							// print the result
							lcd.print(value);
							prevAns = value;
						} else {
							lcd.write("Can'tEvalPostfix");
							#if DEBUG
								Serial.println(postfix);
							#endif
						}
					} else {
						lcd.write("CantConvert2Infx");
						#if DEBUG
							Serial.println(buffer);
						#endif
					}
					buffer     = "";
					expression = "";
				} // It's magic *-* - CapacitorSet
				// Don't question it. Anche perchè neanch'io ho idea di come funzioni. - CapacitorSet
				break;
			case 'D':
				if (shift && ctrl) {
					lcd.scrollDisplayRight();
				} else {
					buffer = buffer.substring(0, buffer.length() - 1);
					expression = expression.substring(0, expression.length() - 1);
					prevKey = '\0'; // E' difficile da spiegare, ma va tenuto altrimenti non si comporta in modo naturale per l'utente.
					// ^ Ora non ho neanche idea di come funzioni, quindi: TODO: capire perché c'è la riga sopra. - CapacitorSet
				}
				break;
		}

		switch (key) {
			/* KEYS */
			// Don't delete the comment above, it is required by make.js.
			// If you wish to implement custom behaviour for a key, do so in the switch statement above this one.
		}

		if (clearScreen == true) {
			lcd.clear();
		}

		if (printBuffer == true) {
			#if DEBUG
				Serial.print("Printing ");
				Serial.println(expression);
			#endif
			lcd.setCursor(0, 0);
			printExpr(expression);
		}
		prevKey = key;
	}
}


