#define MESSAGING_INTERFACE Serial
// Change to Serial if you want to debug the messaging feature using the serial monitor.
// Don't forget to set the line ending to "NL only"!

// Configuration
#define DEBUG true        // Print debug messages to Serial?
#define SHIFT_KEY_PIN 4   // On which pin is the Shift key?
#define CTRL_KEY_PIN 3    // On which pin is the Ctrl key?
#define LCD_COLS 16       // How many columns does the LCD display have?
#define LCD_ROWS 2        // How many rows does the LCD display have?
#define KEYPAD_ROWS 4
#define KEYPAD_COLS 4
char keys[KEYPAD_ROWS][KEYPAD_COLS] = {
	{'1','2','3','+'},
	{'4','5','6','-'},
	{'7','8','9','*'},
	{'S','0','D','/'}
};
byte rowPins[KEYPAD_ROWS] = {12, 11, 10, 9};
byte colPins[KEYPAD_COLS] = { 8,  7,  6, 5};
#define RESULT_PRECISION 8
#define RESULT_MAX_SIZE 64

#include "StackList.h"
#include "infix_postfix.h"
#include "evaluate_postfix.h"
#include "conversion_tools.h"
#include "ShrunkLiquidCrystal.h"
#include "Keypad.h"
#include "QueueArray.h"
#include <EEPROM.h>

void ManageKey(String toBuffer, String toExpression, String &buffer, String &expression, int &latestExpressionLength) {
	buffer     += toBuffer;
	expression += toExpression;
	latestExpressionLength = 1;
}

// Initialize the LCD object with the appropriate pins
ShrunkLiquidCrystal lcd;
// Initialize the keypad with the appropriate data
Keypad customKeypad = Keypad(makeKeymap(keys), rowPins, colPins);

// Per il multitap
char prevKey = '\0'; // The previous key
int tapCount = 0; // The number of consecutive taps so far
unsigned long time = 0; // The timestamp of the latest tap

// Per scrivere
String buffer; // Contiene l'espressione letta dal parser
String expression; // Contiene il testo mostrato sull'LCD
bool textMode = false; // Indica se la text mode è attiva o no
int latestExpressionLength; // So that backspace works correctly with eg. log or tan
/* TODO: fix the line above (turn it into a LIFO stack) */
QueueArray <char> messaggi, emptyQueue; // Rispettivamente, la coda dei messaggi e una coda vuota
int nuoviMessaggi = 0; // Il numero di messaggi non letti

bool waitingForMemoryAddress = false; // Si sta aspettando un indirizzo dall'utente?
bool waitingForData = false; // Si sta aspettando dei dati (da scrivere in EEPROM)?
String memoryAddress; // Stores the memory address between loop() calls

void setup () {
	#if DEBUG
		// Enable the Serial interface for sending debug messages
		Serial.begin (9600);
	#endif
	MESSAGING_INTERFACE.begin(9600);

	lcd.print("Tette *-*");

	pinMode(SHIFT_KEY_PIN, INPUT_PULLUP); // "Keys" are pushbuttons, so they must be read using pullup resistors
	pinMode(CTRL_KEY_PIN, INPUT_PULLUP);
}

void printExpr(String expression) {
	/* Appropriately prints an expression to the LCD display */

	#if DEBUG
		Serial.print("Printing ");
		Serial.println(expression);
	#endif


	lcd.print(expression);
    if(expression.length() > LCD_COLS - 1) { // If the text is longer than the whole screen
		#if DEBUG
			Serial.println("Autoscrolling");
		#endif
		for (int i = 0; i <= expression.length() - LCD_COLS; i++) {
			lcd.scrollDisplayLeft(); // Scroll left exactly expression.length() - LCD_COLS times
		}
	}
}

int getFirstPositionOfBlock(int block) {
	const int realAddress = 64 * (block - 1);
	/*
	 * The code above is equivalent to:
	 *
	 *     blockNum = block--; // Because non-programmers begin counting from 1
	 *     realAddress = 64*blockNum; // The first block starts at 0, the second one starts at 64, the third one at 128...
	 *
	*/
	return realAddress;
}

void send(String message) {
	/* Sends a message on the messaging interface */

	MESSAGING_INTERFACE.print(message); // Don't you dare simplify this to .println! .println uses \r\n as a line terminator, whereas this programme uses \n.
	MESSAGING_INTERFACE.print('\n');
	#if DEBUG
		Serial.print("<- ");
		Serial.println(expression);
	#endif
}

void loop () {
	const char key = customKeypad.getKey();
	bool printExpression = true;
	bool clearScreen = true;
	String toBuffer, toExpression;

	if (key) {
		const bool shift = !digitalRead(SHIFT_KEY_PIN); // It's negated because, well, that's how it's meant to be done.
		const bool ctrl  = !digitalRead(CTRL_KEY_PIN);  // The alternative would be using pulldown resistors, but there is no such thing on an Arduino, which means an external component would be required. Ew.

		// Multitap management
		if (textMode == true) {
			if (key == prevKey && (millis() - time) < 1000) { // If the last tap was <1 second ago
					// Remove the last element inserted in the buffer and in the expression
					tapCount++;
					buffer = buffer.substring(0, buffer.length() - 1);
					expression = expression.substring(0, expression.length() - latestExpressionLength);
			}
			else {
				tapCount = 0;
				prevKey = '\0';
			}
			time = millis(); // Record the time of this tap for future reference
		}

		// Custom keypress behaviour
		switch (key) {
			case '0':
				if (textMode && shift && !ctrl) { // Shift+0 in text mode displays the message count
					printExpression = false;
					clearScreen = false;
					char messageCount[4]; // Allocate 4 characters for the message count (0...9999)

					lcd.setCursor(0, 1);
					lcd.write("                "); // Sedici spazi, in modo da clearare la riga sotto
					lcd.setCursor(0, 1); // E torna all'inizio
					lcd.write(int_string(messageCount, nuoviMessaggi));
					lcd.write(" nuovi messaggi");
				}
				break;
			case '5':
				if (shift && ctrl) { // Shift+Ctrl+5 toggles text mode, no matter the current mode
					printExpression = false;
					clearScreen = false;
					textMode = !textMode;
					#if DEBUG
						Serial.println("Toggling text mode");
					#endif
				}
				break;
			case 'S':
				if (shift && ctrl) { // Shift+Ctrl+S scrolls the display to the right, no matter the current mode.
					printExpression = false;
					clearScreen = false;
					lcd.scrollDisplayRight(); // That's *right*, it's not a typo. This is what the users perceive as "natural" scrolling.
				} else if (shift && !ctrl) { // Shift+S writes to the EEPROM, no matter the current mode
					printExpression = false;
					clearScreen = false;

					// Note that the first case that will be executed is the else case

					if (waitingForMemoryAddress == true) { // If we're expecting an address
						waitingForMemoryAddress = false;
						waitingForData = true;
						memoryAddress = buffer; // Holds the user input between calls to loop()
						buffer = "";
						expression = "";
						lcd.setCursor(0, 0);
						lcd.write("Contenuto?");
					} else if (waitingForData == true) { // If we're expecting data
						waitingForData = false;
						const int realAddress = getFirstPositionOfBlock(memoryAddress.toInt());
						for (int i = 0; i < 64; i++) {
							// Read 64 bytes from expression and copy them to the EEPROM
							EEPROM.write(realAddress + i, expression[i]);
						}

						lcd.setCursor(0,0);
						lcd.print("Scritto in ");
						lcd.print(memoryAddress);
					}  else {
						lcd.setCursor(0, 0);
						lcd.write("Posizione?");
						buffer = "";
						expression = "";
						waitingForMemoryAddress = true;
					}
				} else if (!shift && ctrl) { // Ctrl+S reads the EEPROM, no matter the current mode
					printExpression = false;
					clearScreen = false;

					// Note that the first case to be executed is the else case

					if (waitingForMemoryAddress == true) { // If we're expecting a memory address
						waitingForMemoryAddress = false;
						waitingForData = true;
						memoryAddress = buffer;
						buffer = "";
						expression = "";
						const int realAddress = getFirstPositionOfBlock(memoryAddress.toInt());
						lcd.setCursor(0, 0);
						for (int i = 0; i < 64; i++) {
							char carattere = EEPROM.read(realAddress + i);
							if (carattere != '\0') {
								lcd.write(EEPROM.read(realAddress + i));
							}
						}
					}  else {
						lcd.setCursor(0, 0);
						lcd.write("Posizione?");
						buffer = "";
						expression = "";
						waitingForMemoryAddress = true;
					}
				} else if (!shift && !ctrl && textMode) { // In text mode, S sends a message
					printExpression = false;
					clearScreen = false;
					send(buffer);
					buffer = "";
					expression = "";
					lcd.setCursor(0, 1);
					lcd.write("Inviato!");
				} else if (!shift && !ctrl && !textMode) { // Outside of text mode, S evaluates the current expression
					printExpression = false;
					clearScreen = false;

					lcd.setCursor(0, 1);
					String postfix;
					double numeratore;
					int divisore;
//					double* prevAns; // to be implemented
					char value[RESULT_MAX_SIZE]; // The result, as a char*

					#if DEBUG
						Serial.print("Infix: ");
						Serial.println(buffer);
					#endif
					
					if (infix_postfix (buffer, postfix)) { // try to convert the infix expression to postfix
						#if DEBUG
							Serial.print("Postfix: ");
							Serial.println(postfix);
						#endif

						// try to evaluate the postfix expression
						if (evaluate_postfix (postfix, numeratore, divisore)) {
							// casta il numeratore a string
							double_string (value, numeratore, RESULT_PRECISION);

							lcd.print(value);
							if (divisore != 1) { // se c'è un divisore
								lcd.print('/');
								int_string(value, divisore); // castalo a string prima di printarlo
								lcd.print(value);
							}
						} else {
							lcd.write("Can'tEvalPostfix");
						}
					} else {
						lcd.write("CantConvert2Infx");
					}
					buffer     = "";
					expression = "";					
				}
				break;
			case 'D':
				if (shift && ctrl) { // Shift+Ctrl+D scrolls the display left, no matter the current mode
					printExpression = false;
					clearScreen = false;
					lcd.scrollDisplayLeft(); // See the comment on Shift+Ctrl+S
				} else if (textMode && shift && !ctrl) { // Shift+D in text mode shows the earliest unread message and removes it from memory
					printExpression = false;
					clearScreen = false;

					lcd.clear();
					lcd.setCursor(0, 0);
					if (messaggi.isEmpty()) {
						lcd.write("Nessun messaggio");
					} else {
						char character = messaggi.pop();
						while (character != '\0') { // Keep popping until \0
							character = messaggi.pop();
							if (character != '\0') lcd.write(character);
						}
						nuoviMessaggi--;
					}
				} else {
					buffer = buffer.substring(0, buffer.length() - 1);
					expression = expression.substring(0, expression.length() - latestExpressionLength);
					prevKey = '\0'; // E' difficile da spiegare, ma va tenuto altrimenti non si comporta in modo naturale per l'utente.
					// ^ Ora non ho neanche idea di come funzioni, quindi: TODO: capire perché c'è la riga sopra. - CapacitorSet
				}
				break;
		}

		switch (key) {
			/* KEYS */
			// Don't delete the comment above, it is required by make.js.
			// If you wish to implement custom behaviour for a key, do so in the switch statement above this one.
		}

		if (clearScreen == true) {
			lcd.clear();
		}

		if (printExpression == true) {
			lcd.setCursor(0, 0);
			printExpr(expression);
		}
		prevKey = key;
	}

	if (MESSAGING_INTERFACE.available()) { // As soon as serial data is available
		char inChar = MESSAGING_INTERFACE.read(); // Read a character
		#if DEBUG
			Serial.print("-> ");
			Serial.println(inChar);
		#endif
		if (inChar == '\n') { // Alla fine del messaggio
			#if DEBUG
				Serial.println("Nuovo messaggio queued");
			#endif
			inChar = '\0'; // Aggiungi un fine stringa anziché un newline
			nuoviMessaggi++;
		}
		messaggi.push(inChar); // Pusha il carattere nello stack di messaggi
	}
}
