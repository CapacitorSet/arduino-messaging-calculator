#define SERIAL_INTERFACE Serial
// Change to Serial if you want to debug the messaging feature using the serial monitor.
// Don't forget to set the line ending to "NL only"!

#define DEBUG true
#define SHIFT_KEY_PIN 4
#define CTRL_KEY_PIN 3
#define STATUS_LED_PIN 13
#define LCD_COLS 16
#define LCD_ROWS 2
#define LCD_0 A0
#define LCD_1 A1
#define LCD_2 A2
#define LCD_3 A3
#define LCD_4 A4
#define LCD_5 A5

#define RESULT_PRECISION 8
#define RESULT_MAX_SIZE 64

#define DISPLAY_SIZE 16

#include "StackList.h"
#include "infix_postfix.h"
#include "evaluate_postfix.h"
#include "conversion_tools.h"
#include <LiquidCrystal.h>
#include "Keypad.h"
#include "QueueArray.h"
#include <EEPROM.h>

#define ROWS 4
#define COLS 4
char keys[ROWS][COLS] = {
	{'1','2','3','+'},
	{'4','5','6','-'},
	{'7','8','9','*'},
	{'S','0','D','/'}
};
byte rowPins[ROWS] = {12, 11, 10, 9};
byte colPins[COLS] = { 8,  7,  6, 5};


// initialize the library with the numbers of the interface pins
LiquidCrystal lcd(LCD_0, LCD_1, LCD_2, LCD_3, LCD_4, LCD_5);
Keypad customKeypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);
bool clearScreen = true; // Per cancellare lo splash screen

// Per il multitap
char prevKey = '\0';
int tapCount = 0;
bool textMode = false;
unsigned long time = 0;

// Per scrivere
String buffer;
String expression;
int latestExpressionLength; // So that backspace works correctly with eg. log or tan
QueueArray <char> messaggi, emptyQueue;
int nuoviMessaggi = 0;

bool waitingForMemoryAddress = false;
bool waitingForData = false;
String memoryAddress;

void setup () {
	#if DEBUG
		Serial.begin (9600);
	#endif
	Serial1.begin(9600);

	// Set up the LCD
	lcd.begin(LCD_COLS, LCD_ROWS);
	lcd.print("Tette *-*");

	pinMode(SHIFT_KEY_PIN, INPUT_PULLUP);
	pinMode(CTRL_KEY_PIN, INPUT_PULLUP);
	pinMode(STATUS_LED_PIN, OUTPUT);
}

void printExpr(String expression) {
	lcd.print(expression);
    if(expression.length() > DISPLAY_SIZE - 1) {
		#if DEBUG
			Serial.println("Auto Scrolling");
		#endif
		for (int i = 0; i <= expression.length() - DISPLAY_SIZE; i++) {
			lcd.scrollDisplayLeft();
		}
	}
}

void clear_array(char *string, int length){
	for (int i = 0; i < length; i++)
		string[i] = '\0';
}

void send(String message) {
	SERIAL_INTERFACE.print(message);
	SERIAL_INTERFACE.print('\n');
	#if DEBUG
		Serial.print("<- ");
		Serial.println(expression);
	#endif
}

void loop () {

	const char key = customKeypad.getKey();
	bool printExpression = true;
	bool clearScreen = true;

	if (key) {
		const bool shift = !digitalRead(SHIFT_KEY_PIN);
		const bool ctrl  = !digitalRead(CTRL_KEY_PIN);

		if (textMode == true) {
			if (key == prevKey && (millis() - time) < 1000) {
					tapCount++;
					buffer = buffer.substring(0, buffer.length() - 1);
					expression = expression.substring(0, expression.length() - latestExpressionLength);
					time = millis();
			} // Cancella il token precedente
			else {
				tapCount=0;
				prevKey = '\0';
				time = millis();
			}
		}

		switch (key) {
			case '0':
				if (textMode && shift && !ctrl) {
					printExpression = false;
					clearScreen = false;
					char messageCount[4];

					lcd.setCursor(0, 1);
					lcd.write("                "); // Sedici spazi, in modo da clearare la riga sotto
					lcd.setCursor(0, 1); // E torna all'inizio
					lcd.write(int_string(messageCount, nuoviMessaggi));
					lcd.write(" nuovi messaggi");
				}
				break;
			case '5':
				if (shift && ctrl) {
					printExpression = false;
					clearScreen = false;
					textMode = !textMode;
					#if DEBUG
						Serial.println("Toggling textMode");
					#endif
				}
				break;
			case 'S':
				if (shift && ctrl) {
					printExpression = false;
					clearScreen = false;
					lcd.scrollDisplayRight();
				} else if (shift && !ctrl) {
					printExpression = false;
					clearScreen = false;

					if (waitingForMemoryAddress == true) {
						waitingForMemoryAddress = false;
						waitingForData = true;
						memoryAddress = buffer;
						buffer = "";
						expression = "";
						lcd.setCursor(0, 0);
						lcd.write("Contenuto?");
					} else if (waitingForData == true) {
						waitingForData = false;
						int realAddress = 64 * (memoryAddress.toInt() - 1);
						for (int i = 0; i < 64; i++) {
							EEPROM.write(realAddress + i, expression[i]);
						}
						lcd.setCursor(0,0);
						lcd.print("Scritto in ");
						lcd.print(memoryAddress);
					}  else {
						lcd.setCursor(0, 0);
						lcd.write("Posizione?");
						buffer = "";
						expression = "";
						waitingForMemoryAddress = true;
					}
				} else if (!shift && ctrl) {
					printExpression = false;
					clearScreen = false;

					if (waitingForMemoryAddress == true) {
						waitingForMemoryAddress = false;
						waitingForData = true;
						memoryAddress = buffer;
						buffer = "";
						expression = "";
						int realAddress = 64 * (memoryAddress.toInt() - 1);
						lcd.setCursor(0, 0);
						for (int i = 0; i < 64; i++) {
							lcd.write(EEPROM.read(realAddress + i));
						}
					}  else {
						lcd.setCursor(0, 0);
						lcd.write("Posizione?");
						buffer = "";
						expression = "";
						waitingForMemoryAddress = true;
					}
				} else if (textMode) {
					printExpression = false;
					clearScreen = false;
					send(buffer);
					buffer = "";
					expression = "";
					lcd.setCursor(0, 1);
					lcd.write("Inviato!");
				} else if (!shift && !ctrl && !textMode) {
					printExpression = false;
					clearScreen = false;

					lcd.setCursor(0, 1);
					String postfix;
					double numeratore;
					int divisore;
//					double* prevAns;
					char value[RESULT_MAX_SIZE]; // as string
					
					if (infix_postfix (buffer, postfix)) { // try to convert the infix expression to postfix.
						#if DEBUG
							Serial.print("Postfix: ");
							Serial.println(postfix);
						#endif

						// try to evaluate the postfix expression.
						if (evaluate_postfix (postfix, numeratore, divisore)) {
							// convert the result as string.
							double_string (value, numeratore, RESULT_PRECISION);

							// print the result
							lcd.print(value);
							if (divisore != 1) {
								lcd.print('/');
								int_string(value, divisore);
								lcd.print(value);
							}

							// prevAns[0] = Ans[0];
							// prevAns[1] = Ans[1];
						} else {
							lcd.write("Can'tEvalPostfix");
							#if DEBUG
								Serial.println(postfix);
							#endif
						}
					} else {
						lcd.write("CantConvert2Infx");
						#if DEBUG
							Serial.println(buffer);
						#endif
					}
					buffer     = "";
					expression = "";
					
				} // It's magic *-* - CapacitorSet
				// Don't question it. Anche perchè neanch'io ho idea di come funzioni. - CapacitorSet
				break;
			case 'D':
				if (shift && ctrl) {
					printExpression = false;
					clearScreen = false;
					lcd.scrollDisplayLeft();
				} else if (textMode && shift && !ctrl) { // Shift+D shows the earliest unread message and removes it from memory
					printExpression = false;
					clearScreen = false;

					lcd.clear();
					lcd.setCursor(0, 0);
					if (messaggi.isEmpty()) {
						lcd.write("Nessun messaggio");
					} else {
						char character = 'a';
						while (character != '\0') { // Keeps popping until \0
							character = messaggi.pop();
							if (character != '\0') lcd.write(character);
						}
						nuoviMessaggi--;
					}
					
					if (messaggi.isEmpty() == true) {
						digitalWrite(STATUS_LED_PIN, LOW);
					}
				} else {
					buffer = buffer.substring(0, buffer.length() - 1);
					expression = expression.substring(0, expression.length() - latestExpressionLength);
					prevKey = '\0'; // E' difficile da spiegare, ma va tenuto altrimenti non si comporta in modo naturale per l'utente.
					// ^ Ora non ho neanche idea di come funzioni, quindi: TODO: capire perché c'è la riga sopra. - CapacitorSet
				}
				break;
		}

		switch (key) {
			/* KEYS */
			// Don't delete the comment above, it is required by make.js.
			// If you wish to implement custom behaviour for a key, do so in the switch statement above this one.
		}

		if (clearScreen == true) {
			lcd.clear();
		}

		if (printExpression == true) {
			#if DEBUG
				Serial.print("Printing ");
				Serial.println(expression);
			#endif
			lcd.setCursor(0, 0);
			printExpr(expression);
		}
		prevKey = key;
	}

	if (SERIAL_INTERFACE.available()) { // As soon as serial data is available
		char inChar = SERIAL_INTERFACE.read(); // Read a character
		#if DEBUG
			Serial.print("-> ");
			Serial.println(inChar);
		#endif
		if (inChar == '\n') {
			#if DEBUG
				Serial.println("Nuovo messaggio aggiunto in coda");
			#endif
			inChar = '\0';
			nuoviMessaggi++;
		}
		messaggi.push(inChar);
		digitalWrite(STATUS_LED_PIN, HIGH);
	}
}

