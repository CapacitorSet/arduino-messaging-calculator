#define MESSAGING_INTERFACE Serial
// Change to Serial if you want to debug the messaging feature using the serial monitor.
// Don't forget to set the line ending to "NL only"!

// Configuration
#define DEBUG true        // Print debug messages to Serial?
#define SHIFT_KEY_PIN 4   // On which pin is the Shift key?
#define CTRL_KEY_PIN 3    // On which pin is the Ctrl key?
#define LCD_COLS 16       // How many columns does the LCD display have?
#define LCD_ROWS 2        // How many rows does the LCD display have?
#define LCD_RS_PIN A0     // On which pin is the LCD RS pin?
#define LCD_ENABLE_PIN A1 // On which pin is the LCD Enable pin?
#define LCD_D4_PIN A2     // On which pin is the LCD D4 pin?
#define LCD_D5_PIN A3     // On which pin is the LCD D5 pin?
#define LCD_D6_PIN A4     // On which pin is the LCD D6 pin?
#define LCD_D7_PIN A5     // On which pin is the LCD D7 pin?
#define KEYPAD_ROWS 4
#define KEYPAD_COLS 4
char keys[KEYPAD_ROWS][KEYPAD_COLS] = {
	{'1','2','3','+'},
	{'4','5','6','-'},
	{'7','8','9','*'},
	{'S','0','D','/'}
};
byte rowPins[KEYPAD_ROWS] = {12, 11, 10, 9};
byte colPins[KEYPAD_COLS] = { 8,  7,  6, 5};
#define RESULT_PRECISION 8
#define RESULT_MAX_SIZE 64

#define PRINT_EXPRESSION_BIT 0x01
#define PRINT_EXPRESSION_NEGBIT 0xFE
#define CLEAR_SCREEN_BIT 0x02
#define CLEAR_SCREEN_NEGBIT 0xFD
#define TEXT_MODE_BIT 0x04
#define WAITING_FOR_DATA_BIT 0x08
#define WAITING_FOR_DATA_NEGBIT 0xF7
#define WAITING_FOR_ADDRESS_BIT 0x10
#define WAITING_FOR_ADDRESS_NEGBIT 0xEF
#define SHIFT_BIT 0x20
#define SHIFT_NEGBIT 0xDF
#define CTRL_BIT 0x40
#define CTRL_NEGBIT 0xBF

#define ENABLE_PRINT_EXPRESSION settings |= PRINT_EXPRESSION_BIT
#define DISABLE_PRINT_EXPRESSION settings &= PRINT_EXPRESSION_NEGBIT
#define ENABLE_CLEAR_SCREEN settings |= CLEAR_SCREEN_BIT
#define DISABLE_CLEAR_SCREEN settings &= CLEAR_SCREEN_NEGBIT
#define TOGGLE_TEXT_MODE settings ^= TEXT_MODE_BIT
#define ENABLE_WAITING_FOR_DATA settings |= WAITING_FOR_DATA_BIT
#define DISABLE_WAITING_FOR_DATA settings &= WAITING_FOR_DATA_NEGBIT
#define ENABLE_WAITING_FOR_ADDRESS settings |= WAITING_FOR_ADDRESS_BIT
#define DISABLE_WAITING_FOR_ADDRESS settings &= WAITING_FOR_ADDRESS_NEGBIT
#define ENABLE_SHIFT settings |= SHIFT_BIT
#define DISABLE_SHIFT settings &= SHIFT_NEGBIT
#define ENABLE_CTRL settings |= CTRL_BIT
#define DISABLE_CTRL settings &= CTRL_NEGBIT

#define PRINT_EXPRESSION (settings & PRINT_EXPRESSION_BIT)
#define CLEAR_SCREEN (settings & CLEAR_SCREEN_BIT)
#define TEXT_MODE (settings & TEXT_MODE_BIT)
#define WAITING_FOR_DATA (settings & WAITING_FOR_DATA_BIT)
#define WAITING_FOR_ADDRESS (settings & WAITING_FOR_ADDRESS_BIT)
#define SHIFT (settings & SHIFT_BIT)
#define CTRL (settings & CTRL_BIT)

#include "StackList.h"
#include "infix_postfix.h"
#include "evaluate_postfix.h"
#include "conversion_tools.h"
#include <LiquidCrystal.h>
#include "Keypad.h"
#include "QueueArray.h"
#include <EEPROM.h>

// Initialize the LCD object with the appropriate pins
LiquidCrystal lcd(LCD_RS_PIN, LCD_ENABLE_PIN, LCD_D4_PIN, LCD_D5_PIN, LCD_D6_PIN, LCD_D7_PIN);
// Initialize the keypad with the appropriate data
Keypad customKeypad = Keypad(makeKeymap(keys), rowPins, colPins, KEYPAD_ROWS, KEYPAD_COLS);

// Per il multitap
char prevKey = '\0'; // The previous key
int tapCount = 0; // The number of consecutive taps so far
unsigned long time = 0; // The timestamp of the latest tap

// Per scrivere
String buffer; // Contiene l'espressione letta dal parser
String expression; // Contiene il testo mostrato sull'LCD
int latestExpressionLength; // So that backspace works correctly with eg. log or tan
/* TODO: fix the line above (turn it into a LIFO stack) */
QueueArray <char> messaggi, emptyQueue; // Rispettivamente, la coda dei messaggi e una coda vuota
int nuoviMessaggi = 0; // Il numero di messaggi non letti

byte settings = 0x00; // All values are false

String memoryAddress; // Stores the memory address between loop() calls

void setup () {
	#if DEBUG
		// Enable the Serial interface for sending debug messages
		Serial.begin (9600);
	#endif
	MESSAGING_INTERFACE.begin(9600);

	// Set up the LCD
	lcd.begin(LCD_COLS, LCD_ROWS);
	lcd.print("Tette *-*");

	pinMode(SHIFT_KEY_PIN, INPUT_PULLUP); // "Keys" are pushbuttons, so they must be read using pullup resistors
	pinMode(CTRL_KEY_PIN, INPUT_PULLUP);

	lcd.blink(); // Users be like "oooh, a blinking cursor"
}

void printExpr(String expression) {
	/* Appropriately prints an expression to the LCD display */

	#if DEBUG
		Serial.print("Printing ");
		Serial.println(expression);
	#endif


	lcd.print(expression);
    if(expression.length() > LCD_COLS - 1) { // If the text is longer than the whole screen
		#if DEBUG
			Serial.println("Autoscrolling");
		#endif
		for (int i = 0; i <= expression.length() - LCD_COLS; i++) {
			lcd.scrollDisplayLeft(); // Scroll left exactly expression.length() - LCD_COLS times
		}
	}
}

int getFirstPositionOfBlock(int block) {
	const int realAddress = 64 * (block - 1);
	/*
	 * The code above is equivalent to:
	 *
	 *     blockNum = block--; // Because non-programmers begin counting from 1
	 *     realAddress = 64*blockNum; // The first block starts at 0, the second one starts at 64, the third one at 128...
	 *
	*/
	return realAddress;
}

void send(String message) {
	/* Sends a message on the messaging interface */

	MESSAGING_INTERFACE.print(message); // Don't you dare simplify this to .println! .println uses \r\n as a line terminator, whereas this programme uses \n.
	MESSAGING_INTERFACE.print('\n');
	#if DEBUG
		Serial.print("<- ");
		Serial.println(expression);
	#endif
}

void loop () {
	const char key = customKeypad.getKey();

	if (key) {

		ENABLE_PRINT_EXPRESSION;
		ENABLE_CLEAR_SCREEN;

		if (digitalRead(SHIFT_KEY_PIN)) {
			DISABLE_SHIFT; // Note that if digitalRead returns TRUE, Shift must be DISABLED, because of pullup resistors
		} else {
			ENABLE_SHIFT;
		}
		if (digitalRead(CTRL_KEY_PIN)) {
			DISABLE_CTRL; // Note that if digitalRead returns TRUE, Shift must be DISABLED, because of pullup resistors
		} else {
			ENABLE_CTRL;
		}

		// Multitap management
		if (TEXT_MODE) {
			if (key == prevKey && (millis() - time) < 1000) { // If the last tap was <1 second ago
					// Remove the last element inserted in the buffer and in the expression
					tapCount++;
					buffer = buffer.substring(0, buffer.length() - 1);
					expression = expression.substring(0, expression.length() - latestExpressionLength);
			}
			else {
				tapCount = 0;
				prevKey = '\0';
			}
			time = millis(); // Record the time of this tap for future reference
		}

		// Custom keypress behaviour
		switch (key) {
			case '0':
				if (TEXT_MODE && SHIFT && CTRL) { // Shift+0 in text mode displays the message count
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;
					char messageCount[4]; // Allocate 4 characters for the message count (0...9999)

					lcd.setCursor(0, 1);
					lcd.write("                "); // Sedici spazi, in modo da clearare la riga sotto
					lcd.setCursor(0, 1); // E torna all'inizio
					lcd.write(int_string(messageCount, nuoviMessaggi));
					lcd.write(" nuovi messaggi");
				}
				break;
			case '5':
				if (SHIFT && CTRL) { // Shift+Ctrl+5 toggles text mode, no matter the current mode
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;
					TOGGLE_TEXT_MODE;
					#if DEBUG
						Serial.println("Toggling text mode");
					#endif
				}
				break;
			case 'S':
				if (SHIFT && CTRL) { // Shift+Ctrl+S scrolls the display to the right, no matter the current mode.
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;
					lcd.scrollDisplayRight(); // That's *right*, it's not a typo. This is what the users perceive as "natural" scrolling.
				} else if (SHIFT && !CTRL) { // Shift+S writes to the EEPROM, no matter the current mode
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;

					// Note that the first case that will be executed is the else case

					if (WAITING_FOR_ADDRESS) { // If we're expecting an address
						DISABLE_WAITING_FOR_ADDRESS;
						ENABLE_WAITING_FOR_DATA;
						memoryAddress = buffer; // Holds the user input between calls to loop()
						buffer = "";
						expression = "";
						lcd.setCursor(0, 0);
						lcd.write("Contenuto?");
					} else if (WAITING_FOR_DATA) { // If we're expecting data
						DISABLE_WAITING_FOR_DATA;
						const int realAddress = getFirstPositionOfBlock(memoryAddress.toInt());
						for (int i = 0; i < 64; i++) {
							// Read 64 bytes from expression and copy them to the EEPROM
							EEPROM.write(realAddress + i, expression[i]);
						}

						lcd.setCursor(0,0);
						lcd.print("Scritto in ");
						lcd.print(memoryAddress);
					}  else {
						lcd.setCursor(0, 0);
						lcd.write("Posizione?");
						buffer = "";
						expression = "";
						ENABLE_WAITING_FOR_ADDRESS;
					}
				} else if (!SHIFT && CTRL) { // Ctrl+S reads the EEPROM, no matter the current mode
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;

					// Note that the first case to be executed is the else case

					if (WAITING_FOR_ADDRESS) { // If we're expecting a memory address
						DISABLE_WAITING_FOR_ADDRESS;
						ENABLE_WAITING_FOR_DATA;
						memoryAddress = buffer;
						buffer = "";
						expression = "";
						const int realAddress = getFirstPositionOfBlock(memoryAddress.toInt());
						lcd.setCursor(0, 0);
						for (int i = 0; i < 64; i++) {
							lcd.write(EEPROM.read(realAddress + i));
						}
					}  else {
						lcd.setCursor(0, 0);
						lcd.write("Posizione?");
						buffer = "";
						expression = "";
						ENABLE_WAITING_FOR_ADDRESS;
					}
				} else if (!SHIFT && !CTRL && TEXT_MODE) { // In text mode, S sends a message
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;
					send(buffer);
					buffer = "";
					expression = "";
					lcd.setCursor(0, 1);
					lcd.write("Inviato!");
				} else if (!SHIFT && !CTRL && !TEXT_MODE) { // Outside of text mode, S evaluates the current expression
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;

					lcd.setCursor(0, 1);
					String postfix;
					double numeratore;
					int divisore;
//					double* prevAns; // to be implemented
					char value[RESULT_MAX_SIZE]; // The result, as a char*

					#if DEBUG
						Serial.print("Infix: ");
						Serial.println(buffer);
					#endif
					
					if (infix_postfix (buffer, postfix)) { // try to convert the infix expression to postfix
						#if DEBUG
							Serial.print("Postfix: ");
							Serial.println(postfix);
						#endif

						// try to evaluate the postfix expression
						if (evaluate_postfix (postfix, numeratore, divisore)) {
							// casta il numeratore a string
							double_string (value, numeratore, RESULT_PRECISION);

							lcd.print(value);
							if (divisore != 1) { // se c'è un divisore
								lcd.print('/');
								int_string(value, divisore); // castalo a string prima di printarlo
								lcd.print(value);
							}
						} else {
							lcd.write("Can'tEvalPostfix");
						}
					} else {
						lcd.write("CantConvert2Infx");
					}
					buffer     = "";
					expression = "";					
				}
				break;
			case 'D':
				if (SHIFT && CTRL) { // Shift+Ctrl+D scrolls the display left, no matter the current mode
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;
					lcd.scrollDisplayLeft(); // See the comment on Shift+Ctrl+S
				} else if (TEXT_MODE && SHIFT && !CTRL) { // Shift+D in text mode shows the earliest unread message and removes it from memory
					DISABLE_PRINT_EXPRESSION;
					DISABLE_CLEAR_SCREEN;

					lcd.clear();
					lcd.setCursor(0, 0);
					if (messaggi.isEmpty()) {
						lcd.write("Nessun messaggio");
					} else {
						char character = messaggi.pop();
						while (character != '\0') { // Keep popping until \0
							character = messaggi.pop();
							if (character != '\0') lcd.write(character);
						}
						nuoviMessaggi--;
					}
				} else {
					buffer = buffer.substring(0, buffer.length() - 1);
					expression = expression.substring(0, expression.length() - latestExpressionLength);
					prevKey = '\0'; // E' difficile da spiegare, ma va tenuto altrimenti non si comporta in modo naturale per l'utente.
					// ^ Ora non ho neanche idea di come funzioni, quindi: TODO: capire perché c'è la riga sopra. - CapacitorSet
				}
				break;
		}

		switch (key) {
			/* KEYS */
			// Don't delete the comment above, it is required by make.js.
			// If you wish to implement custom behaviour for a key, do so in the switch statement above this one.
		}

		if (CLEAR_SCREEN) {
			lcd.clear();
		}

		if (PRINT_EXPRESSION) {
			lcd.setCursor(0, 0);
			printExpr(expression);
		}
		prevKey = key;
	}

	if (MESSAGING_INTERFACE.available()) { // As soon as serial data is available
		char inChar = MESSAGING_INTERFACE.read(); // Read a character
		#if DEBUG
			Serial.print("-> ");
			Serial.println(inChar);
		#endif
		if (inChar == '\n') { // Alla fine del messaggio
			#if DEBUG
				Serial.println("Nuovo messaggio queued");
			#endif
			inChar = '\0'; // Aggiungi un fine stringa anziché un newline
			nuoviMessaggi++;
		}
		messaggi.push(inChar); // Pusha il carattere nello stack di messaggi
	}
}